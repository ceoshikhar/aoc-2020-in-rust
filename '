use std::io;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;

fn main() -> io::Result<()> {
    // File handler to read from the input
    let mut file = File::open("input.txt")?;

    // Buffer to store the input
    let mut input = String::new();

    // Read the input from the file and store it in the `contents` buffer string
    file.read_to_string(&mut input)?;

    let inputHashMap = parse_input_to_hash_map(&input);

    Ok(())
}

// The password and the policy that was in effect when the password was created
struct Password {
    // Minimum number of times the `letter` must be present in the `password`
    min_count: u8,

    // Maximum number of times the `letter` can be present in the `password`
    max_count: u8,

    // The letter that must be present in the `password`
    letter: char,

    // The password that we want to check if it's valid according to the policy
    password: String,
}

impl Password {
    fn new(min_count: u8,max_count: u8, letter: char, password: &str)
            -> Password {
       Password {
           min_count: min_count,
           max_count: max_count,
           letter: letter,
           password: password.to_string(),
       }
    }
}

// Generate the hash map from the raw input so that we can actually start
// solving the given puzzel
fn parse_input_to_hash_map(input: &str) {
    let mut min_count: u8 = 0;
    let mut max_count: u8 = 0;
    let mut letter: char;
    let mut password = String::new();

    for line in input.lines() {
        let line_items: Vec<&str> = line.rsplit(' ').collect();
        println!("{:?}", line_items);
        for item in line_items {
            // println!("{:?}", item);
            if item.contains('-') {
                let mut counts = item.split(|num| num == '-');
                // println!("{:?}", counts.next().unwrap());
            }
        }
    }
}
